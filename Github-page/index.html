<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unhooked Engine V2 - Website</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            background-color: #f4f4f4;
            color: #333;
        }

        header, section, footer {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        header h1 {
            color: #3498db;
        }

        section h2 {
            color: #3498db;
        }

        section img {
            max-width: 100%;
            height: auto;
            margin-top: 10px;
        }

        section video {
            width: 100%;
            height: auto;
        }

        a {
            color: #3498db;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        footer {
            text-align: center;
            background-color: #3498db;
            color: #fff;
        }
    </style>
</head>
<body>
    <header>
        <h1>Unhooked Engine V2</h1>
        <p>A 3D game engine created by students from CITM-UPC Terrassa.</p>
    </header>

    <section id="introduction">
        <h2>Introduction</h2>
        <p>Unhooked Engine V2, forked with Sheeesh Engine, is a 3D game engine made by two students, David Ruiz Luengo & Pau Garriga Brotons, as part of their university subject at CITM-UPC Terrassa.</p>
    </section>

     <section id="team">
        <h2>Team</h2>
        <p>Meet the team:</p>
        <div id="member-david">
            <img src="David.jpg" alt="David's Photo" width="200" height="200"> 
            <p><strong>David Ruiz Luengo</strong></p>
            <p><strong>Github: <a href="https://github.com/xdavido">https://github.com/xdavido</a></strong></p>
			
			<p>Tasks:</p>
        <ul>
            <li>Physics Engine Base 2</li>
            <li>Extract Glut</li>
            <li>Add Glew, SDL2, MathGeoLib</li>
            <li>Implement ImGui (FPS, Hardware, options...)</li>
            <li>Load and Save Textures</li>
            <li>Implement DevIL library</li>
            <li>Load FBX (drag and drop)</li>
            <li>Load and Save Image Devil</li>
            <li>Support drag and drop of textures</li>
            <li>Play/Stop/Pause management</li>
            <li>Viewports windows (scene and game)</li>
            <li>Assets tree viewer window</li>
            <li>Timmer</li>
            <li>Load scene</li>
            <li>Create a Particle Module</li>
            <li>Create a Particle System</li>
            <li>Create a Emitter instance</li>
            <li>Apply  Billboard to particles</li>
            <li>Continous  loop smoke come out of 2 houses in scene</li>
            <li>Particle Editor  showed at inspector</li>
            <li>Fire works casts</li>
            <li>Camera animation </li>
            <li>Update Readme</li>
       
			

        </ul>
        </div>
        <div id="member-pau">
            <img src="Pau.jpg" alt="Pau's Photo" width="200" height="200"> 
            <p><strong>Pau Garriga Brotons</strong></p>
            <p><strong>Github: <a href="https://github.com/DonnoNonno">https://github.com/DonnoNonno</a></strong></p>
			
			<p>Tasks:</p>
        <ul>
            <li>Normal vertex and faces</li>
            <li>Draw Normales vertex y faces</li>
            <li>Solve general errors</li>
            <li>ImGui Useful Windows implementation</li>
            <li>Create GameObject Class</li>
            <li>Components transformations</li>
            <li>Camera and Frustrums</li>
            <li>Create particles from menu Gameobjects</li>
            <li>Load and save particles properties</li>
            <li>Saver for tamplated particles in files</li>
            <li>Clean up code</li>
            <li>Update Readme</li>
     
           

        </ul>
        </div>
    </section>

    <section id="core-sub-systems">
        <h2>Core Sub-systems</h2>
        <p>Our engine comprises several core sub-systems:</p>
        <ul>
            <li>Rendering System</li>
            <p>The rendering system is responsible for generating the visual output of the game. It handles rendering 3D models, textures, lighting effects, and shaders to create the graphics displayed on the screen. The goal is to produce realistic and visually appealing scenes.</p>

            <li>Physics System</li>
            <p>The physics system simulates physical interactions within the game world. It manages collision detection and response, object movements, gravity, and other forces. This subsystem ensures that in-game objects behave realistically and interact with each other according to the laws of physics.</p>

            <li>Input Handling System</li>
            <p>The input handling system captures and processes user input from various devices, such as keyboards, mice, game controllers, and touchscreens. It translates input events into actions that can be used to control the game, such as moving characters, triggering abilities, or navigating menus.</p>

            <li>Resource Management System</li>
            <p>The resource management system is responsible for loading, unloading, and managing game assets. It handles textures, models, audio files, and other resources efficiently, ensuring that only the necessary assets are loaded into memory at any given time to optimize performance.</p>

            <li>ImGui</li>
            <p>ImGui, or Immediate Mode Graphical User Interface, is a GUI system that allows developers to create in-game user interfaces. It provides a simple way to create and customize UI elements, such as buttons, sliders, and text boxes, to enhance the user experience during development and debugging.</p>

            <li>Texture Handling</li>
            <p>The texture handling subsystem manages the loading, manipulation, and rendering of textures in the game. It handles tasks such as loading image files, applying textures to 3D models, and managing texture resources efficiently for optimal performance.</p>

            	<li>Scene Loading (GameObjects and Components)</li>
            	<p>The scene loading subsystem is responsible for loading and initializing game scenes. It manages the instantiation of GameObjects and their associated Components, setting up the initial state of the game world based on predefined scene configurations.</p>

            	<li>Hierarchy</li>
            	<p>The hierarchy subsystem provides a structured view of the game objects in the scene. It allows developers to organize and manage the relationships between different game objects, making it easier to navigate and manipulate the game hierarchy during development.</p>

            <li>Camera Movement</li>
            <p>The camera movement subsystem controls the movement and behavior of the in-game camera. It allows players and developers to navigate and explore the game world from different perspectives, enhancing the overall gaming experience and facilitating scene composition.</p>

            	<li>Optimization</li>
            	<p>The optimization subsystem focuses on improving the performance and efficiency of the game engine. It includes techniques such as code optimization, rendering optimization, and resource management to ensure smooth and responsive gameplay even on lower-end hardware.</p>

            	<li>Time Management</li>
            	<p>The time management subsystem is responsible for managing and controlling the flow of time within the game. It ensures consistent frame rates, handles animations, and provides a reliable mechanism for measuring and controlling time-based events.</p>

            	<li>Mouse Picking</li>
            	<p>The mouse picking subsystem allows the selection of game objects in the 3D world using the mouse cursor. It involves techniques to cast rays from the mouse position and determine which object or point in the scene the cursor is interacting with.</p>

            <li>High Level System</li>
            <p>The high-level system encompasses various features and functionalities that operate at a higher level of abstraction. This may include systems related to game logic, artificial intelligence, scripting, and other high-level components that contribute to the overall gameplay experience.</p>
        </ul>
    </section>
	
	<section id="last-assignment">
    <h2>Last Assignment Sub-system</h2>
	<h3>Particles High Level System</h3>
    <p>Last assignment was to implement a particle system inside our general engine:</p>
 <p>The CEmitter component plays a crucial role in our game engine as it defines and oversees particle emitters. When an emitter is created, its constructor sets default values for the particles it will emit. Importantly, the emitter can be linked to a specific object in the game. The Update() and RenderParticles() methods control the regular updates and visualization of the emitter's particles. For user convenience, PrintInspector() offers an interface to adjust emitter properties, and save/load methods enable storing and retrieving the emitter's state from files.
</p>
 <p>The ModuleParticles module takes on the responsibility of globally managing the particle system. Its constructor and destructor handle the initialization and release of module resources. The update methods (PreUpdate, Update, PostUpdate) are in charge of keeping emitters updated and managing logic related to the life and explosion of fireworks. CleanUp() is used to free up memory occupied by emitters. This module also provides functionalities for saving/loading the state of the particle system to/from files. Additionally, castFirework() is a function that creates and launches fireworks with random properties.</p>
 <p>Moving on to the ParticleSystem component, it defines the overall particle system in our game engine. The constructor initializes a system with a fixed-size list of particles. The Update() method takes care of updating particle positions and life. Emit() generates new particles with specific properties. ParticleBuffer() fills buffers with indices and vertices to represent a particle, while Render() displays active particles using OpenGL, applying interpolation to enhance visual quality. Billboard() ensures that particles always face the camera.</p>
 <p>The cohesion of these components is achieved through ModuleParticles, which handles both the update and rendering of emitters and fireworks. ParticleSystem manages the life, emission, and rendering logic of particles. CEmitter defines the specific properties and behavior of individual particles. This system is designed with user-friendliness in mind, offering a straightforward interface to adjust particle properties in real-time. Its modular structure facilitates system expansion and maintenance. In summary, this setup provides a robust foundation for creating and managing dynamic visual effects in graphic environments or games.</p></p>
    <p>Videos:</p>
    <video width="600" height="400" controls loop>
        <source src="smokes.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    <video width="600" height="400" controls loop>
        <source src="fireworks.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    </section>


    <section id="video">
        <h2>Video</h2>
        <p>One-minute speed-up video showing the Engine:</p>
        <video width="600" height="400" controls>
            <source src="scene.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
    </section>

    <section id="repository">
        <h2>Repository</h2>
        <p>Link to the code repository and last release to download:</p>
        <a href="https://github.com/xdavido/UnhookedEngine.v2">GitHub Repository</a><br>
        <a href="https://github.com/xdavido/UnhookedEngine.v2/releases/tag/V.3.0">Latest Release</a>
    </section>

    <section id="license">
        <h2>License</h2>
        <p>Unhooked Engine V2 is licensed under the MIT License:</p>
        <pre>
		MIT License

		Copyright (c) 2023 Pau Garriga Brotons & David Ruiz Luengo

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.

        </pre>
    </section>

    

    <footer>
        <p>&copy; 2024 Unhooked Engine V2. All rights reserved.</p>
    </footer>
</body>
</html>
